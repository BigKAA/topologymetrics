*[English version](check-behavior.md)*

# Контракт поведения проверок

> Версия спецификации: **2.0-draft**
>
> Этот документ описывает поведение проверок здоровья зависимостей:
> жизненный цикл, логику порогов, типы проверок, режимы работы и обработку ошибок.
> Все SDK обязаны реализовать описанное поведение. Соответствие проверяется
> conformance-тестами.

---

## 1. Параметры по умолчанию

| Параметр | Значение | Описание |
| --- | --- | --- |
| `checkInterval` | `15s` | Интервал между началом последовательных проверок |
| `timeout` | `5s` | Максимальное время ожидания ответа от зависимости |
| `initialDelay` | `5s` | Задержка перед первой проверкой после старта SDK |
| `failureThreshold` | `1` | Количество последовательных неудач для перехода в unhealthy |
| `successThreshold` | `1` | Количество последовательных успехов для возврата в healthy |

Все параметры настраиваются:

- Глобально — для всех зависимостей.
- Индивидуально — для конкретной зависимости (приоритет над глобальными).

**Ограничения значений**:

| Параметр | Минимум | Максимум |
| --- | --- | --- |
| `checkInterval` | `1s` | `10m` |
| `timeout` | `100ms` | `30s` |
| `initialDelay` | `0s` | `5m` |
| `failureThreshold` | `1` | `10` |
| `successThreshold` | `1` | `10` |

Значение `timeout` должно быть меньше `checkInterval`. Если задано `timeout >= checkInterval`,
SDK должен вернуть ошибку конфигурации при инициализации.

---

## 2. Жизненный цикл проверки

### 2.1. Диаграмма состояний

```text
Start()
  │
  ▼
[INIT] ── initialDelay ──► [CHECKING]
                               │
                    ┌──────────┤
                    │          │
                    ▼          ▼
              [HEALTHY]   [UNHEALTHY]
                    │          │
                    └────◄─────┘
                   (пороговая логика)
                         │
                    Stop()│
                         ▼
                      [STOPPED]
```

### 2.2. Фазы

#### INIT — инициализация

1. SDK создаёт горутину / поток / задачу для каждой зависимости.
2. Ожидание `initialDelay`.
3. Метрики для этой зависимости **не экспортируются**.

#### CHECKING — активные проверки

1. Выполняется первая проверка.
2. По результату устанавливается начальное состояние: HEALTHY или UNHEALTHY.
3. Метрики начинают экспортироваться.
4. Далее проверки выполняются с интервалом `checkInterval`.

#### HEALTHY / UNHEALTHY — устойчивое состояние

- Состояние меняется только при достижении порога
  (см. раздел 3 "Логика порогов").
- Каждая проверка обновляет `app_dependency_latency_seconds`.
- При изменении состояния обновляется `app_dependency_health`.

#### STOPPED — остановка

1. Вызов `Stop()` / `close()` / graceful shutdown.
2. Отмена контекста / прерывание потоков.
3. Ожидание завершения текущих проверок (с таймаутом `timeout`).
4. Метрики **остаются** с последними значениями (не обнуляются).

**Обоснование**: обнуление метрик при остановке создаёт ложные алерты.
Метрики исчезнут при следующем scrape, если процесс завершился.

### 2.3. Интервал проверок

Интервал `checkInterval` отсчитывается от **начала** предыдущей проверки,
а не от её завершения.

```text
t=0s     t=15s    t=30s    t=45s
│        │        │        │
▼        ▼        ▼        ▼
[check]  [check]  [check]  [check]
 3ms      5ms      2ms      4ms
```

Если проверка занимает больше `checkInterval`, следующая проверка
запускается немедленно после завершения текущей (без пропуска).

---

## 3. Логика порогов

### 3.1. Переход HEALTHY -> UNHEALTHY

```text
failureThreshold = 3

Проверка:  OK   OK   FAIL  FAIL  FAIL  → UNHEALTHY
Счётчик:   0    0    1     2     3
Метрика:   1    1    1     1     0
```

- При каждой неудачной проверке счётчик `consecutiveFailures` увеличивается на 1.
- При успешной проверке счётчик `consecutiveFailures` сбрасывается в 0.
- Когда `consecutiveFailures >= failureThreshold`, состояние переходит в UNHEALTHY.
- Метрика `app_dependency_health` меняется на `0` **в момент достижения порога**.

### 3.2. Переход UNHEALTHY -> HEALTHY

```text
successThreshold = 2

Проверка:  FAIL  FAIL  OK   OK   → HEALTHY
Счётчик:   0     0     1    2
Метрика:   0     0     0    1
```

- При каждой успешной проверке счётчик `consecutiveSuccesses` увеличивается на 1.
- При неудачной проверке счётчик `consecutiveSuccesses` сбрасывается в 0.
- Когда `consecutiveSuccesses >= successThreshold`, состояние переходит в HEALTHY.
- Метрика `app_dependency_health` меняется на `1` **в момент достижения порога**.

### 3.3. Начальное состояние

До первой проверки состояние — **UNKNOWN** (метрика не экспортируется).

Первая проверка определяет начальное состояние:

- Успех → сразу HEALTHY (`app_dependency_health = 1`), без учёта `successThreshold`.
- Неудача → сразу UNHEALTHY (`app_dependency_health = 0`), без учёта `failureThreshold`.

**Обоснование**: при старте сервиса важно как можно быстрее получить
реальный статус зависимости. Пороговая логика защищает от кратковременных
сбоев в устоявшемся режиме.

### 3.4. Счётчики при пороге 1

При `failureThreshold = 1` и `successThreshold = 1` (значения по умолчанию)
каждая проверка немедленно обновляет состояние:

```text
Проверка:  OK   FAIL  OK   FAIL  OK
Метрика:   1    0     1    0     1
```

---

## 4. Типы проверок

### 4.1. HTTP (`type: http`)

| Параметр | Описание | Значение по умолчанию |
| --- | --- | --- |
| `healthPath` | Путь для проверки | `/health` |
| `method` | HTTP-метод | `GET` |
| `expectedStatuses` | Ожидаемые HTTP-статусы | `200-299` (любой 2xx) |
| `tlsSkipVerify` | Пропуск проверки TLS-сертификата | `false` |

**Алгоритм**:

1. Отправить `GET` (или настроенный метод) на `http(s)://{host}:{port}{healthPath}`.
2. Ожидать ответ в пределах `timeout`.
3. Если статус ответа в диапазоне `expectedStatuses` — **успех**.
4. Иначе — **неудача**.

**Особенности**:

- Тело ответа не анализируется (только статус-код).
- Редиректы (3xx) следуются автоматически; проверяется статус финального ответа.
- При `https://` используется TLS; если сертификат невалиден и `tlsSkipVerify = false` — неудача.
- Заголовок `User-Agent: dephealth/<version>`.

### 4.2. gRPC (`type: grpc`)

**Протокол**: [gRPC Health Checking Protocol](https://github.com/grpc/grpc/blob/master/doc/health-checking.md)
(пакет `grpc.health.v1`, метод `Health/Check`).

| Параметр | Описание | Значение по умолчанию |
| --- | --- | --- |
| `serviceName` | Имя сервиса для Health Check | `""` (пустая строка — общий статус) |
| `tlsEnabled` | Использовать TLS | `false` |
| `tlsSkipVerify` | Пропуск проверки TLS-сертификата | `false` |

**Алгоритм**:

1. Установить gRPC-соединение с `{host}:{port}`.
2. Вызвать `grpc.health.v1.Health/Check` с указанным `serviceName`.
3. Если ответ `SERVING` — **успех**.
4. Иные статусы (`NOT_SERVING`, `UNKNOWN`, `SERVICE_UNKNOWN`) — **неудача**.

**Особенности**:

- Соединение создаётся заново для каждой проверки (автономный режим).
- Таймаут передаётся через gRPC deadline.

### 4.3. TCP (`type: tcp`)

**Алгоритм**:

1. Установить TCP-соединение с `{host}:{port}` (с таймаутом `timeout`).
2. Если соединение установлено — **успех**.
3. Немедленно закрыть соединение.

**Особенности**:

- Никакие данные не отправляются и не читаются.
- Подходит для произвольных TCP-сервисов без специфического протокола проверки.

### 4.4. PostgreSQL (`type: postgres`)

| Параметр | Описание | Значение по умолчанию |
| --- | --- | --- |
| `query` | SQL-запрос для проверки | `SELECT 1` |

**Автономный режим**:

1. Установить новое TCP-соединение с PostgreSQL (`{host}:{port}`).
2. Выполнить аутентификацию (если требуется).
3. Выполнить `SELECT 1`.
4. Если получен результат — **успех**.
5. Закрыть соединение.

**Режим с connection pool**:

1. Получить соединение из pool (`db.QueryContext(ctx, "SELECT 1")`).
2. Если запрос успешен — **успех**.
3. Соединение возвращается в pool.

**Особенности**:

- В режиме с pool проверяется не только доступность БД, но и работоспособность pool.
- Если pool исчерпан и `timeout` истёк до получения соединения — **неудача**.
- Поддержка TLS (если указано в connection string).

### 4.5. MySQL (`type: mysql`)

Аналогично PostgreSQL. Единственное отличие — драйвер подключения.

| Параметр | Описание | Значение по умолчанию |
| --- | --- | --- |
| `query` | SQL-запрос для проверки | `SELECT 1` |

### 4.6. Redis (`type: redis`)

**Автономный режим**:

1. Установить TCP-соединение с Redis (`{host}:{port}`).
2. Выполнить аутентификацию (если пароль указан).
3. Отправить команду `PING`.
4. Ожидать ответ `PONG` — **успех**.
5. Закрыть соединение.

**Режим с connection pool**:

1. Использовать существующий клиент (`client.Ping(ctx)`).
2. Если ответ `PONG` — **успех**.

**Особенности**:

- Поддержка Redis Sentinel и Redis Cluster не входит в v1.0.
- Поддержка TLS (`rediss://`).
- Поддержка выбора базы данных (`/0`, `/1`, ...).

### 4.7. AMQP (`type: amqp`)

**Автономный режим**:

1. Установить AMQP-соединение с `{host}:{port}` (с указанным `vhost`).
2. Если соединение установлено (connection.open) — **успех**.
3. Закрыть соединение.

**Особенности**:

- Channel не создаётся (достаточно connection-level проверки).
- Поддержка TLS (`amqps://`).
- Поддержка vhost (из URL или отдельного параметра).
- Аутентификация: username/password из URL или конфигурации.

### 4.8. Kafka (`type: kafka`)

**Автономный режим**:

1. Создать Kafka Admin Client (или минимальный клиент).
2. Отправить Metadata request к брокеру `{host}:{port}`.
3. Если получен ответ с метаданными — **успех**.
4. Закрыть клиент.

**Особенности**:

- Каждый брокер проверяется независимо.
- Проверяется только сетевая доступность брокера и его способность ответить.
- Topic-level проверки не входят в v1.0.
- Поддержка SASL-аутентификации не входит в v1.0.

---

## 5. Два режима работы

### 5.1. Автономный режим (Standalone)

SDK **создаёт новое соединение** для каждой проверки.

```text
SDK → net.Dial / http.Get / sql.Open → проверка → Close
```

**Когда использовать**:

- Зависимость не имеет connection pool в сервисе (HTTP, gRPC, TCP).
- Разработчик не предоставил ссылку на pool.

**Преимущества**:

- Простая конфигурация — достаточно URL.
- Не зависит от состояния pool сервиса.

**Недостатки**:

- Не отражает реальную способность сервиса работать с зависимостью.
- Если pool исчерпан, автономная проверка всё ещё покажет `healthy`.
- Дополнительная нагрузка (создание/закрытие соединений).

### 5.2. Режим с connection pool (Integrated)

SDK **использует существующий connection pool** сервиса.

```text
SDK → pool.GetConnection() → SELECT 1 / PING → pool.Release()
```

**Когда использовать**:

- Зависимость использует connection pool (БД, Redis).
- Разработчик предоставил ссылку на pool / client.

**Преимущества**:

- Отражает реальную способность сервиса работать с зависимостью.
- Если pool исчерпан — проверка покажет `unhealthy`.
- Нет дополнительных соединений.

**Недостатки**:

- Требует передачи ссылки на pool при инициализации.
- Зависит от конкретной библиотеки (go-redis, database/sql и т.д.).

### 5.3. Приоритет

Режим с pool является **предпочтительным**. SDK должен поощрять его использование
в документации и примерах. Автономный режим — fallback для случаев,
когда pool недоступен.

---

## 6. Обработка ошибок

Все перечисленные ситуации трактуются как **неудача** проверки:

| Ситуация | Поведение |
| --- | --- |
| Таймаут (`timeout` истёк) | Неудача. Латентность = фактическое время до таймаута |
| DNS resolution failure | Неудача. Латентность = время до ошибки DNS |
| Connection refused | Неудача. Латентность = время до получения RST |
| Connection reset | Неудача. Латентность = время до сброса |
| TLS handshake failure | Неудача. Латентность = время до ошибки TLS |
| HTTP 5xx | Неудача (не 2xx) |
| HTTP 3xx (redirect) | Следует редиректу; результат определяется финальным ответом |
| HTTP 4xx | Неудача (не 2xx) |
| gRPC NOT_SERVING | Неудача |
| SQL ошибка (аутентификация, синтаксис) | Неудача |
| Pool exhausted (таймаут получения соединения) | Неудача |
| Panic / unhandled exception | Неудача. SDK должен перехватить и логировать |

### 6.1. Логирование ошибок

SDK логирует каждую ошибку проверки с уровнем `WARN`:

```text
WARN dephealth: check failed dependency=postgres-main host=pg.svc port=5432 error="connection refused"
```

Первый переход в unhealthy логируется с уровнем `ERROR`:

```text
ERROR dephealth: dependency unhealthy dependency=postgres-main host=pg.svc port=5432 consecutive_failures=3
```

Возврат в healthy логируется с уровнем `INFO`:

```text
INFO dephealth: dependency recovered dependency=postgres-main host=pg.svc port=5432
```

### 6.2. Классификация ошибок

Каждая ошибка проверки классифицируется в **категорию статуса** и **детальное значение**.
Эта классификация используется для заполнения метрик `app_dependency_status` и
`app_dependency_status_detail` (см. metric-contract.ru.md, разделы 8-9).

#### 6.2.1. Цепочка классификации

Планировщик классифицирует ошибки по следующей цепочке приоритетов:

1. **Интерфейс ClassifiedError** — если ошибка реализует интерфейс `ClassifiedError`
   (Go: `StatusCategory() string` + `StatusDetail() string`;
   Java/C#: базовый класс исключения; Python: свойства на `CheckError`),
   используются её категория и detail.
2. **Sentinel-ошибки** — известные типизированные ошибки (`ErrTimeout`, `ErrConnectionRefused`,
   `ErrUnhealthy` и т.д.) маппятся на соответствующую категорию/detail.
3. **Определение по платформенным ошибкам** — проверяются стандартные типы ошибок:
   - `context.DeadlineExceeded` / `TimeoutException` → `timeout` / `timeout`
   - `*net.DNSError` / `UnknownHostException` / `socket.gaierror` → `dns_error` / `dns_error`
   - `*net.OpError` (connection refused) / `ConnectException` → `connection_error` / `connection_refused`
   - `*tls.CertificateVerificationError` / `SSLException` → `tls_error` / `tls_error`
4. **Fallback** — нераспознанные ошибки → `error` / `error`.

#### 6.2.2. Успешная проверка

Успешная проверка (без ошибки) всегда даёт:

- категория статуса: `ok`
- detail: `ok`

#### 6.2.3. Значения detail по типам чекеров

| Тип чекера | Возможные значения detail |
| --- | --- |
| HTTP | `ok`, `timeout`, `connection_refused`, `dns_error`, `tls_error`, `http_NNN` (например, `http_404`, `http_503`), `error` |
| gRPC | `ok`, `timeout`, `connection_refused`, `dns_error`, `tls_error`, `grpc_not_serving`, `grpc_unknown`, `error` |
| TCP | `ok`, `timeout`, `connection_refused`, `dns_error`, `error` |
| PostgreSQL | `ok`, `timeout`, `connection_refused`, `dns_error`, `auth_error`, `tls_error`, `error` |
| MySQL | `ok`, `timeout`, `connection_refused`, `dns_error`, `auth_error`, `tls_error`, `error` |
| Redis | `ok`, `timeout`, `connection_refused`, `dns_error`, `auth_error`, `unhealthy`, `error` |
| AMQP | `ok`, `timeout`, `connection_refused`, `dns_error`, `auth_error`, `tls_error`, `unhealthy`, `error` |
| Kafka | `ok`, `timeout`, `connection_refused`, `dns_error`, `no_brokers`, `error` |

#### 6.2.4. Маппинг detail → status

| detail | status |
| --- | --- |
| `ok` | `ok` |
| `timeout` | `timeout` |
| `connection_refused`, `network_unreachable`, `host_unreachable` | `connection_error` |
| `dns_error` | `dns_error` |
| `auth_error` | `auth_error` |
| `tls_error` | `tls_error` |
| `http_NNN`, `grpc_not_serving`, `grpc_unknown`, `unhealthy`, `no_brokers` | `unhealthy` |
| `error`, `pool_exhausted`, `query_error` | `error` |

#### 6.2.5. Обратная совместимость

Интерфейс `HealthChecker` **не меняется**. Чекеры, не возвращающие
классифицированные ошибки, обрабатываются определением по платформенным ошибкам
и fallback в цепочке классификации (шаги 3-4). Пользовательские чекеры
автоматически получают классификацию через этот механизм.

### 6.3. Паника / неожиданные ошибки

SDK обязан перехватывать panic (Go), unhandled exception (Java/C#/Python)
внутри проверки. Паника не должна прерывать работу планировщика.
Проверка считается неудачной, ошибка логируется с уровнем `ERROR`.

---

## 7. Конкурентность и потокобезопасность

- Проверки разных зависимостей выполняются **параллельно** (каждая в своей горутине / потоке).
- Проверки разных endpoint-ов одной зависимости также выполняются **параллельно**.
- Обновление метрик — **потокобезопасно** (гарантируется Prometheus-клиентом).
- Обновление внутреннего состояния (счётчики порогов) — **потокобезопасно**
  (atomic / mutex / synchronized).
- `Start()` и `Stop()` можно вызвать только один раз. Повторный вызов `Start()`
  возвращает ошибку. Повторный вызов `Stop()` — no-op.
